(function (window) {
  "use strict";
  
  // Check if web crypto is avaliable
  if (!window.crypto || !window.crypto.subtle) {
    console.error("Web Crypto API unavailable. Please use a secure context (HTTPS or localhost).");
    return;
  }

  // Internal variables
  let key = null;
  let salt = null;

  //<(---- Helper Functions for Conversion ----)>
  function _bufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }

  function _base64ToBuffer(base64) {
    const binary = window.atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  //<(---- Function to Set the Key Using a Passphrase ----)>
  /**
   * Create an AES-256-GCM key from a passphrase.
   *
   * @param {string} pass - The passphrase.
   * @param {string | Uint8Array} [customSalt] - Optional custom salt in base64 or Uint8Array format.
   * @returns {Promise<string>} - Returns the salt (in base64) used for future reuse.
   */
  async function setPassword(pass, customSalt) {
    // If a custom salt is provided, convert it
    if (customSalt) {
      salt = typeof customSalt === "string" ? _base64ToBuffer(customSalt) : customSalt;
    } else {
      salt = window.crypto.getRandomValues(new Uint8Array(16));
    }
    
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(pass),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    
    key = await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt: salt,
        iterations: 100000,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    
    return _bufferToBase64(salt);
  }

  //<(---- Encryption Function ----)>
  /**
   * Encrypts plaintext using AES-GCM.
   *
   * @param {string} plaintext - The text to encrypt.
   * @returns {Promise<Object>} - An object containing the encrypted data, IV, and salt (all in base64).
   */
  async function encrypt(plaintext) {
    if (!key) {
      throw new Error("Password not set. Please call BrownBear.setPassword first.");
    }
    // Generate a 12-byte Initialization Vector (IV)
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);
    const encryptedBuffer = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv: iv },
      key,
      data
    );
    return {
      data: _bufferToBase64(encryptedBuffer),
      iv: _bufferToBase64(iv),
      salt: _bufferToBase64(salt)
    };
  }

  //<(---- Decryption Function ----)>
  /**
   * Decrypts a ciphertext encrypted with AES-GCM.
   *
   * @param {string} ciphertextBase64 - The encrypted text in base64.
   * @param {string} ivBase64 - The Initialization Vector used during encryption (in base64).
   * @returns {Promise<string>} - The decrypted plaintext.
   */
  async function decrypt(ciphertextBase64, ivBase64) {
    if (!key) {
      throw new Error("Password not set. Please call BrownBear.setPassword first.");
    }
    const ciphertext = _base64ToBuffer(ciphertextBase64);
    const iv = _base64ToBuffer(ivBase64);
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: iv },
      key,
      ciphertext
    );
    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
  }

  //<(---- Global Exposure ----)>
  // Expose the module as a global object "BrownBear"
  window.BrownBear = {
    setPassword: setPassword,
    encrypt: encrypt,
    decrypt: decrypt,
    // Optionally expose helper functions:
    _bufferToBase64: _bufferToBase64,
    _base64ToBuffer: _base64ToBuffer
  };

})(window);
